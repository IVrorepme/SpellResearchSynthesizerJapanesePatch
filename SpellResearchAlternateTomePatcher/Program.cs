using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;

using System.IO;
using System.Text.RegularExpressions;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Order;

namespace SpellResearchAlternateTomePatcher
{

    public class Program
    {
        static Lazy<Settings> settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "alteredtomespatch.esp")
                .SetAutogeneratedSettings(
                    nickname:"Altered Tomes Patcher Settings",
                    path: "alteredtomesettings.json",
                    out settings)
                .Run(args);

        }

        // fixes some things with formids in spellresearch scripts and returns a formkey
        private static FormKey fixformid(string fid, ModKey mk) {

            FormKey formKey;
            var fkeystr = fid + ":" + mk.FileName;
            
            // hex value and too many zeroes
            if (fid.Contains("0x", StringComparison.OrdinalIgnoreCase))
            {
                // first try to convert directly
                if (FormKey.TryFactory(fkeystr, out formKey))
                {
                    return formKey;
                }

                // handle ESL's
                if (fid.Substring(0, 2).Equals("FE")) {
                    fid = "00000" + fid.Substring(5, 3);
                }
                else {
                    // to make str processing easier
                    fid = fid.Replace("0x", "00").PadLeft(6, '0');
                    
                    // hardcoded load order for some reason, (papyrus is fine with this apparently)
                    if (fid.Length == 8 && !fid.Substring(0, 2).Equals("00")) {
                        fid = "00" + fid.Substring(2, 6);
                    }
                    // needs to be 8 digits for mutagen
                    if (fid.Length > 6) {
                        fid = fid.Substring(fid.Length - 6, 6);
                    }
                }
                fkeystr = fid + ":" + mk.FileName;
                return FormKey.Factory(fkeystr);
            }
            // decimal value
            else
            {
                int num = Convert.ToInt32(fid, 10);
                string h = num.ToString("X");
                if (!h.Contains("0x", StringComparison.OrdinalIgnoreCase))
                {
                    h = "0x" + h;
                }
                return fixformid(h, mk);

            }
        }

        // removes 'Spell Tome' elements from description name
        public static string fix_name(IBookGetter book, Regex rnamefix)
        {
            var n = book?.Name?.ToString() ?? "";
            MatchCollection mnamefix = rnamefix.Matches(n);
            if (mnamefix.Count > 0)
            {
                n = mnamefix.First().Groups["tomename"].Value.Trim();
            }

            return n;
        }

        // Creates a string description of a spell given its archetypes
        private static string process_text(Dictionary<string, dynamic> spell)
        {

            string strbuilder = "";
            strbuilder += "A " + spell["level"];
            strbuilder += " spell of the " + spell["skill"] + " school, cast ";

            if (spell["casting"].Equals("Concentration"))
                strbuilder += "through immense Concentration. ";
            else if (spell["casting"].Equals("FireForget"))
                strbuilder += "by Firing and Forgetting. ";

            for (int i = 0; i < spell["target"].Count; i++) {
                string a = spell["target"][i];
                if (a.Equals("Actor"))
                    strbuilder += "This spell is fired where Aimed. "; 
                else if (a.Equals("AOE"))
                    strbuilder += "This spell has an AREA of Effect. ";
                else if (a.Equals("Location"))
                    strbuilder += "This spell is cast in a specific Location. ";
                else if (a.Equals("Self"))
                    strbuilder += "This spell is cast on Oneself. ";
            }

            if (spell["element"].Count > 0) {
                strbuilder += "Elements of ";
                int idx=0;
                // for ([i, e] of spell["element"].entries()) {
                foreach (string e in spell["element"]) {
                    if (idx == 0)
                        strbuilder += e;
                    else
                        if (idx == spell["element"].Count - 1)
                            strbuilder += " and " + e;
                        else
                            strbuilder += ", " + e;
                    idx+=1;
                }
                strbuilder += ". ";
            }

            if (spell["technique"].Count > 0) {
                strbuilder += "The technique to cast this spell is of ";
                int idx=0;
                foreach (string t in spell["technique"]) {
                    if (idx == 0)
                        strbuilder += t;
                    else
                        if (idx == spell["technique"].Count - 1)
                            strbuilder += " and " + t;
                        else
                            strbuilder += ", " + t;
                    idx+=1;
                }
                strbuilder += ".";
            }

            return strbuilder;
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {

            // stuff at the start
            string PREAMBLE = "<font face'$HandwrittenFont'><font size='40'><p align='center'><br>";
            string PAGE = "<br><br>[pagebreak]<br><br><font face'$HandwrittenFont'><font size='20'><p align='left'><br><br>";

            foreach (string modpsc in settings.Value.pscnames)
            {
                Console.WriteLine(modpsc);

                string modname = modpsc.Split(";")[0].Trim();
                string pscname = modpsc.Split(";")[1].Trim();

                var modKey = ModKey.FromFileName(modname);
                if (!state.LoadOrder.ContainsKey(modKey))
                {
                    Console.WriteLine("WARNING: Mod not Found: {0}", modname);
                    continue;
                }


                var scriptPath = Path.Combine(state.DataFolderPath, "scripts", "source", pscname);
                if (!File.Exists(scriptPath)) {
                    Console.WriteLine("WARNING: Script not Found: {0}", scriptPath);
                    continue;

                }

                string[] lines = File.ReadAllLines(scriptPath);
                int spellcount = 0;
                Dictionary<string, dynamic> archetypemap = new Dictionary<string, dynamic>();
                Regex rx = new Regex("^.*\\(\\s*(?<fid>(0x)?[a-fA-F0-9]+),\\s\"(?<esp>.*\\.es[pml])\".*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                Regex rnamefix = new Regex("^.+\\s+(Tome)\\:?(?<tomename>.+)$", RegexOptions.Compiled | RegexOptions.IgnoreCase);


                Regex rskill = new Regex("^.*_SR_ListSpellsSkill(?<skill>[A-Za-z]+).*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                Regex rcasting = new Regex("^.*_SR_ListSpellsCasting(?<casting>[A-Za-z]+).*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                Regex rlevel = new Regex("^.*_SR_ListAllSpells[1-5](?<level>[A-Za-z]+).*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                Regex rtarget = new Regex("^.*_SR_ListSpellsTarget(?<target>[A-Za-z]+).*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                Regex rtechnique = new Regex("^.*_SR_ListSpellsTechnique(?<technique>[A-Za-z]+).*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                Regex relement = new Regex("^.*_SR_ListSpellsElement(?<element>[A-Za-z]+).*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);

                // parse the psc
                foreach (string line in lines)
                {
                    // start of spell in psc
                    if (line.Contains("TempSpell", StringComparison.OrdinalIgnoreCase) && line.Contains("GetFormFromFile", StringComparison.OrdinalIgnoreCase))
                    {
                        spellcount++;
                        archetypemap = new Dictionary<string, dynamic>();
                        archetypemap["skill"] = "";
                        archetypemap["casting"] = "";
                        archetypemap["level"] = "";
                        archetypemap["target"] = new List<string>();
                        archetypemap["technique"] = new List<string>();
                        archetypemap["element"] = new List<string>();
                    }
                    // ignore removeaddedform
                    else if (line.Contains("RemoveAddedForm", StringComparison.OrdinalIgnoreCase))
                    {
                        continue;
                    }
                    // end of spell
                    else if (line.Contains("TempTome", StringComparison.OrdinalIgnoreCase) && line.Contains("GetFormFromFile", StringComparison.OrdinalIgnoreCase) && spellcount >= 1)
                    {
                        MatchCollection matches = rx.Matches(line);
                        string fid = matches.First().Groups["fid"].Value.Trim();
                        string esp = matches.First().Groups["esp"].Value.Trim();

                        // get the modkey from the esp in the psc
                        var good_modkey = ModKey.TryFromFileName(esp, out modKey);
                        if (!good_modkey)
                        {
                            Console.WriteLine("ERROR: could not determine mod: {0} for {1}, skipping", esp, fid);
                            continue;
                        }
                        // get formkey for book and get text
                        FormKey fkey = fixformid(fid, modKey);
                        Console.WriteLine(fkey.ToString());
                        string desc = process_text(archetypemap);
                        var bookLink = new FormLink<IBookGetter>(fkey);

                        if (bookLink.TryResolve(state.LinkCache, out var bookRecord))
                        {
                            var bookOverride = state.PatchMod.Books.GetOrAddAsOverride(bookRecord);
                            bookOverride.Teaches = new BookTeachesNothing();
                            bookOverride.BookText = "" + PREAMBLE + fix_name(bookRecord, rnamefix) + PAGE + desc;
                            Console.WriteLine("DESC: {0}", bookOverride.BookText);

                        }
                        else {
                            Console.WriteLine("ERROR: Could Not Resolve {0}", fkey.ToString());
                        } 

                    }
                    // spellcount >= 1 to ignore all the spellresearch import stuff
                    else if (spellcount >= 1)
                    {
                        MatchCollection mskill = rskill.Matches(line);
                        MatchCollection mcasting = rcasting.Matches(line);
                        MatchCollection mlevel = rlevel.Matches(line);
                        MatchCollection mtarget = rtarget.Matches(line);
                        MatchCollection mtechnique = rtechnique.Matches(line);
                        MatchCollection melement = relement.Matches(line);
                        if (mskill.Count > 0)
                        {
                            archetypemap["skill"] = mskill.First().Groups["skill"].Value.Trim();
                        }
                        else if (mcasting.Count > 0)
                        {
                            archetypemap["casting"] = mcasting.First().Groups["casting"].Value.Trim();
                        }
                        else if (mlevel.Count > 0)
                        {
                            archetypemap["level"] = mlevel.First().Groups["level"].Value.Trim();
                        }
                        else if (mtarget.Count > 0)
                        {
                            archetypemap["target"].Add(mtarget.First().Groups["target"].Value.Trim());
                        }
                        else if (mtechnique.Count > 0)
                        {
                            archetypemap["technique"].Add(mtechnique.First().Groups["technique"].Value.Trim());
                        }
                        else if (melement.Count > 0)
                        {
                            archetypemap["element"].Add(melement.First().Groups["element"].Value.Trim());
                        }

                    }

                }

            }

        }

    }
}
